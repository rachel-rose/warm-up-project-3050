Presentation: https://docs.google.com/presentation/d/1zQa-DC8zkzIkw1l-kNDZYIt7j_Es49RBsUYdG3j7AwY/edit#slide=id.g2b93c8671e8_2_0

## warm-up-project-3050
# Deliverable 2 (Description of Query Language)
What do we want the user to be able to search by?
Year of publication
Title
Director
Rating
Genre
Duration
Recommended
If a given movie received awards

Comparison Keywords: >, <, ==, >=, <=, of, and, or

Expected tokens for the parser language
year
name
director
rating
genre
duration
recommend
awards

Command options
Queries (described above)
help
quit

Help message for invalid request (using keyword help or when entering an invalid query):
“Invalid Request: 
Try using the following format: token comparison value ex: year > 2020
Token: category name
Comparison:  >, <, ==, >=, <=, of, and, or
Value:  “The Fast and the Furious”
Range query
Common formatting errors to avoid: 
Tokens (catergory names) should not be capialized or in quotes 
When searching by values (a specific movie name, genre, etc..), it must be in double quotation marks 
Integers and floats do not have to be in quotation marks 


Example queries:
?? year <= 1980
Rear Window, Vertigo, Monty Python and the Holy Grail, Rocky, Attack of the Killer Tomatoes
?? title == “Rocky”
Rocky, 1976, John G. Avildsen, Rating: 8.1, Drama, Recommended, 120 minutes, (Awards)
?? rating > 8.8
The Shawshank Redemption, Forrest Gump, Fight Club, Inception
?? genre == “Horror” and rating > 6.5
Midsommar
?? recommend == “no” or rating < 5.0
Pacific Rim Uprising, The Other Side of the Door, Jurassic World, Shazam, Elvis, The Gingerdead Man, Attack of the Killer Tomatoes, Zapped, Women Talking, Zombeavers
?? awards of “Ford v Ferrari”
2 Oscars, 3 Golden Globes
?? awards of “G Force”
None

For the interface between the parser and the query program, the user would enter a query string such as “year > 2020”. The parsed strings generated by the parser would be: “year”, “>”, “2020”. These values would be added to lists that are passed to the query function when it is called in the parser. This function exists in the query program and will access the database and retrieve the movies that meet the criteria and return them as a list of strings.
query(token[], comparison[], value[] )

The same can be done with a compound query such as year and genre. The lists make it possible to pass multiple tokens, comparisons, and values to the query program in the correct order.
year > 2020 and genre== “Horror”
Parsed phrase: “year”, “>”, “2020”, “and”, “genre”, “==”, “Horror”
query(token[], comparison[], value[] )
In this case, the token[] list would contain: [“year”, “genre”], the comparison[] list would contain: [“>”, “==”], and the value[] list would contain: [“2020”, “Horror”].

# Deliverable 1
This dataset was created by our team and it consists of an unordered list of movies chosen by the members of our team. The dataset holds 42 movies and will be stored in a Movies collection. Each document in the Movies collection contains the following 8 fields:
id - a unique integer value
name - a string representing the title of the movie
year - an integer representing the year the movie was released
director - a string describing the director of the film
rating - a float value ranging from 0.0 to 10.0 representing the IMBD rating of the movie
genre - a string which describes the genre of the movie, according to IMDB
duration - an integer value showing the duration of the film in minutes
recommended - a boolean value set to true if we would recommend the movie to others and false otherwise
awards- a string representing if a film won an award (ocars and golden globes) or not. This is an optional field.

including the name of the top-level collection; and a description of the entities in the top-level collection. If you choose to use subcollections, then also describe the name of the subcollection that a document in the top-level collection might have; and provide a description of the entities in a subcollection
